import numpy as np
from Main_classes import DataSaver as dsv
from Main_classes import Pattern_handler as Paha
from Main_classes import HopfieldNetwork as hopfn
import os


def image_finder(image, file_name = 'Yoshi', update_rule = 'asynchronous_hebbian', **file_path):
    """
    @summary: this class recieves a broken image in the form of an 1D ndarray
            and it's associated weight matrix and tries to fix it given a specific update rule
    """
    if not bool(file_path):
        raise ValueError("There is no file_path please select one from the autogenerated directories")
    else:
        print("\n\nWelcome, your image is being sampled and retrieved, please wait for the project to load \n")
    img_shape = np.shape(image)
    modified_image = image.copy()

    #image modifier different implementation are possible
    hiding_block1 = np.ones((100,25))
    hiding_block2 = np.ones((25,75))
    modified_image[0:100,75:100] =  hiding_block1
    modified_image[75:100,0:75] = hiding_block2

    #both the image and the distorted image are flattened
    binary_pattern = np.where(image == 0, -1, 1).flatten()
    perturbed_image = np.where(modified_image == 0, -1, 1).flatten()
    # for random pixel perturbation
    # perturbed_image = Generator.perturb_pattern(binary_pattern, 4500)

    saver = dsv.DataSaver()
    Generator = Paha.Pattern_handler()
    index = Generator.random_indexer(50)
    rdn_patterns = Generator.generate_patterns(50, 10000)
    rdn_patterns[index] = binary_pattern

    if update_rule == 'synchronous_hebbian':
        Hopf_netwk = hopfn.HopfieldNetwork(rdn_patterns, rule='hebbian')
        Hopf_netwk.dynamics(perturbed_image, saver,30)
        Hopf_netwk.__del__()
    elif update_rule == 'asynchronous_hebbian':
        Hopf_netwk = hopfn.HopfieldNetwork(rdn_patterns, rule='hebbian')
        Hopf_netwk.dynamics_async(perturbed_image, saver, 50000, 5000, 500)
        Hopf_netwk.__del__()
    elif update_rule == 'synchronous_storkey':
        Hopf_netwk = hopfn.HopfieldNetwork(rdn_patterns, rule='storkey')
        Hopf_netwk.dynamics(perturbed_image, saver, 30)
        Hopf_netwk.__del__()
    elif update_rule == 'asynchronous_storkey':
        Hopf_netwk = hopfn.HopfieldNetwork(rdn_patterns, rule='storkey')
        Hopf_netwk.dynamics_async(perturbed_image, saver, 50000, 5000, 500)
        Hopf_netwk.__del__()
    else:
        saver.__del__()
        raise NameError("The possible update rules are only 'synchronous_hebbian', 'asynchronous_hebbian', 'synchronous_storkey' or 'asynchronous_storkey'")
    #creates the video
    saver.save_video(os.path.join(file_path["Videos"], update_rule+'_'+file_name + '_video.mp4'), img_shape = img_shape[0])
    print("A video with the", update_rule,"rule has been created and stored in the Videos directory. \n\n")
